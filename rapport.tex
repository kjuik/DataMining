% Author: Till Tantau
% Source: The PGF/TikZ manual
\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amsmath}    % need for subequations
\usepackage{graphicx}   % need for figures
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
%\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs
\usepackage{url}
\usepackage{float}
\usepackage{todonotes}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{pdfpages}
\usepackage{caption}
\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{color}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage[T1]{fontenc} % use for allowing < and > in cleartext
\usepackage{fixltx2e}    % use for textsubscript
\usepackage[linesnumbered,boxed,ruled]{algorithm2e}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
%\newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\left(#1\right)}}
\newcommand{\BigO}[1]{\ensuremath{\mathop{}\mathopen{}\mathcal{O}\mathopen{}\left(#1\right)}}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  %title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\bibliographystyle{plain}
\begin{document}
\graphicspath{ {./images/} }
\date{May 21st 2014}
\title{Mining build orders in StarCraft 2: Heart of the Swarm}

\author{Andrea Catalini\\
\texttt{acat@itu.dk}
\and Michał Królikowski\\
\texttt{mikrl@itu.dk}
\and Rick Marker\\
\texttt{rdam@itu.dk}}

\clearpage\maketitle
\thispagestyle{empty}
\setcounter{page}{1}
\begin{abstract}
This report will look at analyzing data from the real time strategy game StarCraft 2. The data will come from replay files uploaded to internet, and the questions we will try to answer is the following: Using the sequence in which actions were taken, is it possible to see if the player won or lost. Furthermore we will also if there is a relation between a players skill level (indicated by which league he represents) and the order in which he performs actions. We will answer the first question by using the ID3 algorithm, and the second question by clustering the data using the k-means algorithm and evaluate whether each cluster represents a league. Our results indicate that the order in which actions are used can not be used to predict a winner, nor does it serve to predict a players league.
\end{abstract}

%\newpage
%\setcounter{page}{1}

\section{Introduction}
In this paper we will be looking at the real time strategy game StarCraft 2 by Blizzard Entertainment. 
In StarCraft 2 you play as 1 of 3 races: Protoss, Terran and Zerg. It is possible to play alone against another player, or in teams. As your skill increases you win more matches and when you win matches you will move to higher leagues, in match equally skilled players together. The game is monthly played by XXX gamers and is one of the most popular eSports, making it an interesting domain to study.
Specifically we will be researching whether it is possible to answer the following questions based on the order in which a player creates building and uses abilities (hereafter called actions):
\begin{enumerate}
%\item Is it possible to predict what race this player played against? \label{q:opponent}
\item Is it possible to predict who will win?\label{q:win}
\item When clustering the action order, will it line up with the league indices?\label{q:league}
\end{enumerate}

We will explore \ref{q:win} by using the ID3 algorithm. This will give us the immediate answer to the questions, but equally interesting is it that we can see what the biggest differentiator on winning and losing is. In \ref{q:league} we will use k-means \todo{Can be changed} to check if action order are related to league index. The reason behind is we want to figure out whether action order alone is enough to make a good player, assuming good players will be in better leagues.

\subsection{Data set}
The data used is obtained by crawling \url{Gamereplays.org} for data files.
These files were in a format called 'sc2replay', used by StarCraft 2, to show replays. Due to difference in formats, we are only focusing on files from the expansion pack Heart of the Swarm. This gave us just 462 replay files. The data which can be found in these files include: Winner, the players races, the players legaues, build order of each player, abilities order by each player, units killed by each player.
For each of the attributes, which were a list, a timestamp was given to be able to relate each event to each other.\\

We note that when we want to answer our questions based on the order of actions we only mean the sequence in which they were used, not using the exact information about when they were build.

\section{Preprocessing}
In order to use both ID3 and k-means we had to preprocess the files. We started by reformatting the data, so the data was not centered around a game, but rather a player.
In effect this meant breaking ties between player and opponents, but as the only information we needed about the opponent was the race, we added this information to the new player-tuple.

We then cleaned our data from some noise, in form of modded games. These were found by looking at the buildings used and if a player made an action which is not possible as that race, the tuple would be removed. We note that this may not remove all modded games, as multiple mods exist, and not all of them involve buildings, but could involve how many resources. Furthermore it is possible that some Zerg plays has been filtered out as one of the units have an ability to take over a opposing race. The ability is rarely used, so we assumed this a precice way of filtering.

Afterwards the goal was to limit our dimensions. As each race is able to do about 70 different actions (depending on race), and on average 280 actions are performed (in our data set), our space would be too sparse with those dimensions. So first we decided to group the actions into categories, instead of looking at each action individually. We came up with 7 categories: 'Structure for building fighters', 'Structure to improve economy', 'Defensive structures', 'Workers', 'Ground units', 'Advanced fighters', 'Upgrades'.

Then we wanted to reduce the list of actions taken. We had two approaches regarding this: Group actions into bins, or group resource usage into bins. The idea being that one category would be the representative for that bin.

\subsection{Action-based binning}
At first we tried to group actions into bins using only the first 110 actions, filtering out plays with fewer than 110 action. 110 was a judgement call, keeping in mind that we wanted as many actions as possible, while avoiding filtering away too many tuples.
We noted that the filtering introduces some bias, as strategies such as 'Zerg Rush'\footnote{A strategy where a Zerg player builds small ground units to take the opponent unaware}, will be filtered away as it contains considerably fewer actions than 110.
The way the representative was chosen, was by looking at which action was done the most. The main reason we thought this approach unfit, was that it weighted each actions equally high no matter the actual cost of that action. 

\subsection{Resource-based binning}
To remedy the problems with action based binning, we tried binning according to resources. The idea being that each bin would represent a fraction of the total resources used.
By doing it this way around, we would not need to filter according to number of actions, introducing no bias in this way.
As multiple kinds of resources exist in StarCraft 2, we decided to add weight to each kind of resources, so a straight forward comparison could be made. We asked a domain specialist about his best approximation of weights.
As we only asked one domain specialist, and no clear concensus has been established these weights introduces some bias into the experiment.
Furthermore we made the bins of different sizes keeping the bins in the early game smaller, as the actions taking in that part of the game are cheaper. This was to prevent that the high resource usage towards the end would result in too many actions towards the start being binned together. The sizes of the bins have been chosen by looking at the data and approximating fair splits for the bins.

In the following, the approach which binned by resources will be used, as it seemed less biased and did not filter away data points.
A comparison was made between the two approaches was made, and it seemed there was little difference between them.

\section{Predicting who will win}

\section{Clustering the data}

\section{Discussion}
We think our experiments prove that there is no correlation between build order, whether you win or which league you are in. Though we realize that many improvements could be done in order to make our conclusion more sound.

First of all, a bigger data set should be used. This is very feasible as new replay files are uploaded every day.
Secondly there is a part of the preprocessing where weights for the resources are chosen. As our domain specialist noted, the weights in game are not static, but changes from map to map, and even during the course of a single game. Having a set value for each resource will not produce the optimal result.

Should one extend upon the work, we would advise to take into account another factor. That could be resource management, or possibly the actual build times, and not just the sequence information, where actual build times seems more like the natural extension.

\section{Conclusion}


\newpage

\begin{thebibliography}{}

\bibitem{paper:example}
Bibitem Example


\end{thebibliography}

%code in appendix
\section*{Appendix}
\appendix

%\lstinputlisting[language=Python]{../src/dsbf.py}


\end{document}
